// Dynamic Programming

#include <unordered_map>
#include <vector>

// Returns the n-th fibonacci number (optimized with memoization).
//
// Time: O(n)
// Space: O(n) auxiliary
int64_t fib(int32_t n) {
  static std::unordered_map<int, int64_t> cache;

  if (n <= 2) return 1;
  if (cache.contains(n)) return cache[n];

  cache[n] = fib(n - 1) + fib(n - 2);
  return cache[n];
}

// Asserts whether the given target sum can be generated by any combination of numbers from the given vector
// (a number can be used more than once).
bool can_sum(const int target, const std::vector<unsigned int> &nums, std::unordered_map<unsigned int, bool> &cache) {
  if (cache.contains(target)) return cache[target];
  if (target == 0) return true;
  if (target < 0) return false;

  for (const unsigned int &n : nums) {
    cache[target - n] = can_sum(static_cast<int>(target - n), nums, cache);
    if (cache[target - n]) return true;
  }
  return false;
}
